---
title: "バリデーションせずパースせよ（翻訳）"
emoji: "🦍"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["関数型プログラミング"]
published: false
---

こちらは[Parse, don’t validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)の翻訳です。
元の記事がエッセイ調になっており、特に口語的な表現の部分で、多くの訳者の意訳を含みます。

---

長年の間、私は簡潔でシンプルな型駆動設計が何を意味するかを説明する方法を見つけるのに苦労していました。「どうやってこのアプローチを思いついたのですか？」と聞かれることがあまりに多かったのです。私は彼らに十分な答えを示せずにいることに気づいていました。

もちろんこれらは突然私の前に現れたのではなく、繰り返される設計のプロセスがあり、パッと口から出たものではありません。しかし、他の人にこれを伝えることはうまくいっていませんでした。

しかし、およそ1ヶ月前、JSONを静的に-そして動的に型付言語にパースしたときに経験した違いについて[Twitter上で振り返っていた](https://twitter.com/lexi_lambda/status/1182242561655746560)時、ついに私が探していたものを見つけました。

# バリデーションせずパースせよ (Parse, don’t validate.)

## 型駆動設計（type-driven design）のエッセンス

ええ、正直に言いましょう。あなたがすでに、型駆動設計が何かを知らない限り、私のキャッチーなスローガンは全く意味をなさないでしょう。幸運なことに、それはこの投稿があなたに役立つということを意味します。私はこれから生々しいほどに正確に、そして詳細に説明します。しかし、その前に、少し希望的観測で練習する必要があります。

## 起こりうることの範囲 (The realm of possibility)

静的型システムの美点の一つは「この関数を書くことはあり得るか」という質問にさえ、容易に答えることがあることです。極端な例えですが、以下のようなHaskellのHaskellの型定義を考えてみましょう。

```hs
foo :: Integer -> Void
```

`foo`関数を実装することは可能でしょうか？`Void`が値を含まない型であることから、答えがNoであることは自明です。この例はあまりにつまらないですが、この質問はより現実的な例を選ぶとより面白くなります。

```hs
head :: [a] -> a
```

この関数はリストの最初の要素を返します。この関数を実装することは可能でしょうか？確かにこれは特に複雑な事には思えませんが、もしこれを実装しようとすると、コンパイラーは満足しないでしょう。

```hs
head :: [a] -> a
head (x:_) = x
```

```
warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘head’: Patterns not matched: []
```

このメッセージは私たちの関数がPartial（部分函数と部分的、不完全をかけている）だということを示してくれています。あらゆるすべての入力に対して定義されているわけではないのです。特に入力が空のリスト`[]`だったときの定義が不足しています。これは確かにそうでしょう。空のリストの最初の要素を返すことはできません。返す要素などないのですから。

## 部分写像を全域写像にする (Turning partial functions total)

動的型付言語のバックグランドの人にとっては、このことは面倒なことに思えるかもしれません。もしリストがあれば、リストから要素を取得するのに苦労はしないかもしれません。そして確かに、「リストの最初の要素を取得すること」はHasckellでは不可能ではありません。ただ、少しの儀式を加える必要があるのです。この`head`関数を直す方法は2つあります。ここではもっとも簡単なものから始めましょう。

## 期待値を調整する (Managing expectations)

すでに見たように、`head`関数は空のリストが入力として与えられたときに返す要素がないため不完全です。幸運なことにこのジレンマを解消するのは簡単です。約束を弱めればいいのです。関数を呼び出す人がリストに1つの要素を含めることを保証できないので、期待値を調整する必要があります。つまり、一つの要素を返すことに最善を尽くすが、何も返さない権利も確保しておくのです。Haskellではこの可能性を`Maybe`型を使って表現します。

```hs
head :: [a] -> Maybe a
```

これによって私たちは`head`関数を実装する自由を得ます。結果的に`a`という型を生み出すことができないとわかった時に、Nothingを返すことが許されました。

```hs
head :: [a] -> Maybe a
head (x:_) = Just x
head []    = Nothing
```

問題解決です…ね？この瞬間は…はい、しかしこの方法には見えないコストがあります。

`Maybe`型を返すことは、`head`関数を実装する上で疑いなく便利です。しかし、「利用」する際には、著しく不便になります。
`head`は常に`Nothing`を返すことがありうるので、その可能性に対処するという負債は呼び出し側にのしかかるこのになります。そして、時にそれは信じられないほどにイライラするものになります。どうしてかは次のコードを考えるとわかります。

```hs
getConfigurationDirectories :: IO [FilePath]
getConfigurationDirectories = do
  configDirsString <- getEnv "CONFIG_DIRS"
  let configDirsList = split ',' configDirsString
  when (null configDirsList) $
    throwIO $ userError "CONFIG_DIRS cannot be empty"
  pure configDirsList

main :: IO ()
main = do
  configDirs <- getConfigurationDirectories
  case head configDirs of
    Just cacheDir -> initializeCache cacheDir
    Nothing -> error "should never happen; already checked configDirs is non-empty"
```

`getConfigurationDirectories`が実行環境からファイルパスのリストを検索する時、事前にリストがからでないことをチェックします。しかし、`head`がリストの最初の要素を取得するために`main`の中で使われる時、`Maybe FilePath`という結果によって、絶対にあり得ないとわかっている`Nothing`型に対処しなければなりません。これは以下のいくつかの理由からひどく悪いことです。

1. 第1に、ただ鬱陶しいです。すでに空ではないとチェックしたリストのに、どうして冗長なチェックでコードを散らかさないといけないのでしょうか？
1. 第2に、潜在的なパフォーマンスコストがあります。この典型例での冗長なチェックのコストはとるに足らないものですが、もっと複雑なシナリオでの冗長なチェックはまるでびっしりとしたループの中で起こっているかのように、増し加えられていきます。
1. 最後に、また最悪なことに、このコードはバグが起きることを招き寄せています。もし、意図的かどうかに関わらず`getConfigurationDirectories`がリストが空でないことをチェックすることを、やめてしまったらどうでしょうか？プログラマーは`main`を苦心するのを覚えていないかもしれません。そしてある日突然、「あり得ない」エラーがあり得るだけではなく、起こりそうになるのです。

冗長なチェックへのニーズは、型のついたシステムに穴を開けてしまいます。もし私たちが静的に`Nothing`になることはあり得ないと*証明*することができれば、`getConfigurationDirectories`がリストの要素があることをチェックすることをやめても証明が無効になり、コンパイル時にエラーになるのです。しかしながら、書いてある通り、テストケースの手動の検査によってバグを見つけることを強いられているのです。

## 前払いする (Paying it forward)

明らかに修正版の`head`はいくつか改善が望まれる余地があります。なんとかして、より賢くしたいです。もしリストが空ではないとすでにチェックされていたなら、`head`は条件によらず、最初の要素を返すはずです。あり得ないケースを扱うことを強制する必要もありません。どうしたらできるでしょうか？

元々の（不完全な）`head`の型定義を見てみましょう。

```hs
head :: [a] -> a
```

前節では戻り値の約束を弱めることで部分的な型を完全な型にする方法を説明しました。しかし、そんなことはしたくないので、もう一つの方法を取ることにします。引数の型（今回で言うと`[a]`）を変えるのです。戻り値の型を弱める代わりに、入力の型を*強める*のです。それによって、`head`が空のリストに対してよばれる可能性を完全に排除できます。

そのためには、空ではないリストの型を表現する必要があります。幸運なことに、`Data.List.NonEmpty`の`NonEmpty`型がまさしくそれです。これは以下のように定義されています。

```hs
data NonEmpty a = a :| [a]
```

`NonEmpty`は元々本当にただの`a`と`a`の空の可能性があるリストであることに注目してください。これは最初の要素と残りの要素を分けて保管することで空ではないリストを便利にモデリングしています。これによって`head`の実装は完全に取るに足らないものになります。

```hs
head :: NonEmpty a -> a
head (x:|_) = x
```

さっきとは異なり、GHCはこの定義を文句なく受け入れます。この定義は*完全*で部分的ではありません。この定義を使えば実装は以下のようにできます。

```hs
getConfigurationDirectories :: IO (NonEmpty FilePath)
getConfigurationDirectories = do
  configDirsString <- getEnv "CONFIG_DIRS"
  let configDirsList = split ',' configDirsString
  case nonEmpty configDirsList of
    Just nonEmptyConfigDirsList -> pure nonEmptyConfigDirsList
    Nothing -> throwIO $ userError "CONFIG_DIRS cannot be empty"

main :: IO ()
main = do
  configDirs <- getConfigurationDirectories
  initializeCache (head configDirs)
```

`main`の中で冗長なチェックが一切なくなったことに注目してください！代わりに、`getConfigurationDirectories`の中でチェックがまさに1回だけ行われています。これにより`Data.List.NonEmpty`の`nonEmpty`関数を使って`[a]`から`NonEmpty a`が作り出されています。`nonEmpty`関数は以下のような型になっています。

```hs
nonEmpty :: [a] -> Maybe (NonEmpty a)
```

`Maybe`型はまだ姿を見せていますが、今回は、`Nothing`の場合をとても明確にすることができています。まさに入力値のバリデーションを行っていたのと同じ場所です。一度そのチェックを通せば、`NonEmpty FilePath`型の値を手にすることができます。それはつまり、リストが空ではないという知識を残すことになります。（型システムによって！）

`head`の結果の型を弱める代わりに、引数の型を強めることで前の節での問題を完全に取り除くことができました。
- コードには冗長なチェックはなく、何のパフォーマンスオーバーヘッドもありません
- さらに、もし`getConfigurationDirectories`がリストが空でないことのチェックを止めるように変更された場合、戻り値の型が必ず変わります。同時に`main`の型検証が失敗して、プログラムを実行する前に問題を知ることができるのです。

さらに加えると、元の`head`の振る舞いを`nonEmpty`で`head`を実装することで、置き換えることができます。

```hs
head' :: [a] -> Maybe a
head' = fmap head . nonEmpty
```

この逆は真*ではない*ことに注目してください。新しいバージョンの`head`から古いものを得ることはできません。結局のところ、第2のアプローチの方がすべての軸で優れています。

## パースの力 (The power of parsing)

あなたはもしかすると上の例はこの投稿のタイトルと何の関係があるのかと首を考えているかもしれません。結局、リストが空でないことをバリデーションする2つの方法を試してみただけで、パースについては触れてもいません。その解釈は間違っていませんが、もう一つの視点を提案したいと思います。私の考えではバリデーションとパースの違いはほぼすべてどのように情報が保持されるかと言うことにあるのです。以下の2つの関数について考えてみてください。

```hs
validateNonEmpty :: [a] -> IO ()
validateNonEmpty (_:_) = pure ()
validateNonEmpty [] = throwIO $ userError "list cannot be empty"

parseNonEmpty :: [a] -> IO (NonEmpty a)
parseNonEmpty (x:xs) = pure (x:|xs)
parseNonEmpty [] = throwIO $ userError "list cannot be empty"
```

これらの2つの関数はほぼ同一です。与えられたリストが空ではないことをチェックしています。そしてもし空ならエラーメッセージと共にプログラムを中断します。その違いはすべて戻り値の型にあります。`validateNonEmpty`は常に`()`を返します。その方には何の情報もありません。しかし、`parseNonEmpty`は入力値の改良版である`NonEmpty a`を返します。これによって型システムのなかに、獲得した知識を保持することになります。これらの関数のどちらの同じことをチェックしていますが、`parseNonEmpty`は呼び出し側に学習した情報へアクセスできるようにしていますが、`validateNonEmpty`はただその情報を放り捨ててしまっています。

これらの2つの関数は型システムの2つの異なる観点を見事に説明しています。
`validateNonEmpty`は型検査に十分従っていますが、`parseNonEmpty`のみがその最大の恩恵を受けることができています。どうして`parseNonEmpty`の方が好ましいかわかれば、私が「バリデーションせずパースせよ」というマントラで何を意味しているかを理解したことになります。まだ、もしかするとあなたは`parseNonEmpty`の名前に疑いを持っているかもしれません。それは本当になんでも*パース*(構文解析)しているのでしょうか？それともただ入力をバリデーションして結果を返しているだけなのでしょうか？パースとバリデーションの正確な定義は議論があるものである一方で、私は`parseNonEmpty`が正真正銘のパーサーであると信じています（特段シンプルなものではありますが）。

「パーサーとは何か」考えてみてください。本当にパーサーとはただのより構造化されていない入力を消費して、より構造化された出力を生み出すだけのただの関数にすぎません。原理的に、パーサーは部分関数です。ドメイン内の一部の値は範囲内のどの値にも対応しません。そのため、すべてのパーサーはいくらかの失敗という概念を持たざるを得ません。しばしば、パーサーの入力はテキストですが、必ずそうでなければならないということでは決してありません。そして`parseNonEmpty`は完全に*そこそこの*パーサーです。リストを空ではないリストにパースして失敗する時にはエラーを吐いてプログラムを終了します。

柔軟な定義のもとパーサーは信じられないほど強力なツールになりました。入力値のチェックをちょうどプログラムと外界の境目でチェックできるようになり、1度これを行えば全く再チェックしなくて良くなったのです！Haskellerはこの力をよく知っています。そして彼らはたくさんの種類のパーサーを日頃から使っているのです。

- [aeson](https://hackage.haskell.org/package/aeson) はJSONをパースしてドメインの型として使えるようにするパーサーを提供します。
- 似たように、 [optparse-applicative](https://hackage.haskell.org/package/optparse-applicative) はコマンドライン引数のためmpいくつかのパーサーの組み合わせを扱えるようにするライブラリです。
- [persistent](https://hackage.haskell.org/package/persistent) や[postgresql-simple](https://hackage.haskell.org/package/postgresql-simple) といったデータベースのライブラリは外部のデータストアが持っているデータをパースする機構を持っています。
- [servant](https://hackage.haskell.org/package/servant)エコシステムはHaskellのデータタイプをパスコンポーネントやクエリパラメーター、HTTPヘッダーなどからパースする仕組みで作られています。

これらのすべてのライブラリに共通するテーマは外界とHaskellアプリケーションの境界上にあるものだということです。それらは和型や積型ではなく、Byteのストリームであるため、なんらかのパースを行う必要がありません。データに対処する前にパースを行うことは、多くの種類の重大なセキュリティの問題を含むバグを回避することに役立ちます。

1つこのすべての最初にパースするアプローチに欠点があるとすれば、しばしば値がパースされるのが実際に使われるよりも大幅に前になってしまうことです。このことは動的型付言語ではパースと処理のロジックに一貫性をもたせることを少し難しくします。莫大なテストカバレッジなしがあればこれらの問題を防ぐことができますが、ほとんどの場合はそのテストのメンテナンスに非常に手間がかかります。しかし、静的型付システムでは、問題が驚くほどシンプルになります。上記の`NonEmpty`の例で示された通りです。つまり、もしパースと処理のロジックに一貫性がない場合、そのプログラムはコンパイルすることすら失敗します。

## バリデーションの危険性 (The danger of validation)

願くば、この時点で、あなたは少なくともパースの方がバリデーションよりも好ましいという考え方に感化されていて欲しいですが、まだ、疑いをひきずっているかもしれません。もし型システムが必要なチャックを強制するとしたら、バリデーションは本当にそんなに悪いものなのでしょうか。もしかするとエラーの見え方は少し悪くなるかもしれませんが、少しの冗長なチェックはそんなに辛くないですよね？

残念なことに、話はそうシンプルではありません。その場その場でのバリデーションは[言語理論的セキュリティ](http://langsec.org/)領域における*ショットガンパーシング*という現象につながります。2016年の論文の [The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them](http://langsec.org/papers/langsec-cwes-secdev2016.pdf)では著者たちが下記のような定義をしています。

> ショットガンパーシングはパースおよび入力値のバリデーションコードを処理コードと混合して全体に分散させるプログラミングのアンチパターンです。つまり、入力に対して大量のチェックを投げかけ、体系的な正当性なしに、そのうちの 1 つまたは 2 つがすべての「悪い」ケースをキャッチすることを期待します。
>> 原文
>> Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code—throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the “bad” cases.

彼らは続けてそのようなバリデーション手法に内在する問題について説明しています。

> ショットガンパーシングは必然的にプログラムから不正な入力を処理せずに拒否する能力を奪います。入力のストリームの中で遅くなってから発見されたエラーは結果として処理ずみの不正な入力の一部になるでしょう。その結果プログラムの状態を正確に予測することが難しくなります。
>> 原文
>> Shotgun parsing necessarily deprives the program of the ability to reject invalid input instead of processing it. Late-discovered errors in an input stream will result in some portion of invalid input having been processed, with the consequence that program state is difficult to accurately predict.

言い換えると、最初にすべての入力をパースしていないプログラムは、有効な入力に対して対処しているときに、異なる部分が不正であると発見し、どんな処理が実行済みであろうとも、一貫性を維持するために、突然巻き戻さなければならなくなるリスクにあります。時々（RDBMSのトランザクション処理などでは）こういったことは可能ですが、一般的にはそうではありません

ショットガンパーシングがバリデーションとどういう関係にあるかは直ちに明らかになることはないかもしれませんが、結局のところ、すべてのバリデーションを最初にやっておけばショットガンパーシングのリスクを軽減することができます。問題は、バリデーションベースのアプローチは全てが実際に最初にバリデーションされたのか、もしくはいわゆる「起こり得ない」ケースが実際に起こるのかを確かめることを極端に難しくする、または不可能にすることです。プログラムの全体は例外がどこでも発生させることが起こりうるだけではなく、むしろ定期的に起こる必要があると想定する必要があります。

パースはこの問題を2つのフェーズに階層分けすることで回避しています。パースと実行です。この場合、不正な入力による失敗は最初のフェーズでしか起こり得ません。実行の中での残りの失敗は比べて最小であり最大限の注意を持ってそれらをケアすることができます。

## バリデーションせずパースせよの実践（Parsing, not validating, in practice）

今の所このブログポストは何かのセールスピッチです。「そこの読者のあなた、パースしないわけにはいきません！」と言っているような感じです。そしてもし私がちゃんと仕事ができたのであれば、少なくとも読者のうちの何人かはこの考え方を購入してくれたでしょう。しかしながら、たとえあなたが「何を」「どうして」やらないといけないのか理解できたとしても、「どうやって」やればいいのかまだ自信がないかもしれません。

私のアドバイスは「データ型に集中しなさい」です。


